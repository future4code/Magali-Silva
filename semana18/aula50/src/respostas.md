### Semana 18 - Aula 50: Introdução a Autenticação

### Exercício 1:
*a. Qual a sua opinião em relação a usar strings para representar os ids? Você concorda que seja melhor do que usar números?*

Concordo, pois strings permitem uma quantidade infinita de combinações, tornando o id mais consistente e seguro.



*b. A partir de hoje vamos tentar isolar, ao máximo, as nossas lógicas dentro de funções. Isso vai deixar nosso código mais organizado e aumentar a facilidade da manutenção e refatoração. Dado isso, crie uma função para gerar um id.*
```
import {v4} from 'uuid'

export function generateId(): string {
    return v4()
}
```





### Exercício 2:
```
const userTableName = "User";

const connection = knex({
  client: "mysql",
  connection: {
    host: process.env.DB_HOST,
    port: 3306,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE_NAME,
  },
});

const createUser = async (id: string, email: string, password: string) => {
  await connection
    .insert({
      id,
      email,
      password,
    })
    .into(userTableName);
};
```
*a. Explique o código acima com as suas palavras.*

Na constante *connection* é criada a conexão com o banco de dados e a função da constante *createUser* insere um usuário na tabela userTableNmae.


*b. Comece criando a tabela de usuários. Coloque a query que você utilizou no arquivo de respostas.*
~~~SQL
CREATE TABLE aula50_users(
	id VARCHAR(255) NOT NULL PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL
);
~~~


*c. Pela mesma justificativa do exercício anterior, crie uma função para ser responsável pela criação de usuários no banco.*
```
import { connection } from '..'

export async function insertUser(
    id: string,
    email: string,
    password: string
): Promise<void> {
    try {
        await connection('aula50_users')
        .insert({
            id,
            email,
            password
        })
        
    } catch (error) {
        throw new Error(error.message || error.sqlMessage)
    }
};
```

### Exercício 3:
*a. O que a linha as string faz? Por que precisamos usar ela ali?*

Transforma o parâmetro em string.

*b. Agora, crie a função que gere o token. Além disso, crie um type  para representar o input dessa função*

```
import * as jwt from 'jsonwebtoken'
import { AuthenticationData } from '../types'

export const generateToken = (payload: AuthenticationData): string => {
    return jwt.sign(
        payload,
        process.env.JWT_KEY as string,
        {
            expiresIn: "2min"
        }
    )
}
```

### Exercício 4:
*a. Crie o endpoint que realize isso, com as funções que você implementou anteriormente*

*b. Altere o seu endpoint para ele não aceitar um email vazio ou que não possua um `"@"`*

*c. Altere o seu endpoint para ele só aceitar uma senha com 6 caracteres ou mais*

a, b, c :
```
import { Request, Response } from 'express'
import { generateId } from '../service/idGenerator'
import { insertUser } from '../data/insertUser'
import { generateToken } from '../service/authenticator'

export const createUser = async (req: Request, res: Response) => {
    try {
        const { email, password } = req.body
        let message = 'User created and token generated by jwt'

        if (!email || !password) {
            res.statusCode = 406
            message = 'Missing "email" and/or "password"'
            throw new Error(message)
        }

        if (!email.includes('@')) {
            message = 'missing "@" in the email'
            throw new Error(message)
        }

        if (password.length < 6) {
            message = 'Password must be at least 6 characters'
            throw new Error(message)
        }

        const id: string = generateId()

        await insertUser(id, email, password)
        
        const token: string = generateToken({
            id
        })

        res.status(200).send({ message: message,
        token: token })
    } catch (error) {
        res.status(400).send({ message: error.sqlMessage || error.message })
    }
}
```

### Exercício 5:
*a. Crie uma função que retorne as informações de um usuário a partir do email*
```
import { connection } from '..'
import { User } from '../types';

export async function getUserByEmail(
    email: string
): Promise<User> {
    try {
        const result = await connection('aula50_users')
        .select("*")
        .where({email});
        
        return {
            id: result[0],
            email: result[0].email,
            password: result[0].password
        }
        
    } catch (error) {
        throw new Error(error.message || error.sqlMessage)
    }
};
```


### Exercício 6:
*a. Crie o endpoint que realize isso, com as funções que você implementou anteriormente*

*b. Altere o seu endpoint para ele não aceitar um email vazio ou que não possua um `"@"`*
```
import { Request, Response } from 'express'
import { generateToken } from '../service/authenticator'
import { User } from '../types'
import { selectUserByEmail } from '../data/selectUserByEmail'

export const login = async (req: Request, res: Response) => {
    try {
        
        const {email, password} = req.body
        let message: string = 'user is loged and token generated by jwt'

        if (!email || !password) {
            res.statusCode = 406
            message = 'Missing "email" and/or "password"'
            throw new Error(message)
        }

        if (!email.includes('@')) {
            message = 'missing "@" in the email'
            throw new Error(message)
        }

        const user: User | undefined = await selectUserByEmail(email)

        if (!user) {
            res.statusCode = 404
            message = 'user not found or wrong email/password'
            throw new Error(message)
        }

        if (user.password !== password) {
            res.statusCode = 404
            message = 'user not found or wrong email/password'
            throw new Error(message)
        }
        
        const token: string = generateToken({
            id: user.id
        })

        res.status(200).send({ message: message,
        token: token })
        
    } catch (error) {
        res.status(400).send({ message: error.sqlMessage || error.message })
    }
}
```


### Exercício 7:
*a. O que a linha as any faz? Por que precisamos usá-la ali?*
*b. Crie uma função que realize a mesma funcionalidade da função acima*
```
export const getTokenData = (
    token: string
): AuthenticationData => {
    return jwt.verify(
        token,
        process.env.JWT_KEY as string
    ) as AuthenticationData
}
```


